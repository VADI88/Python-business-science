from pydantic import (
    BaseModel,
    StrictFloat,
    ConfigDict,
    Field,
    model_validator
)
from typing import Literal, Annotated
from tqdm import tqdm
import pandas as pd
from sktime.forecasting.arima import AutoARIMA
import numpy as np
import pandas_flavor as pf


class Forecaster(BaseModel):
    """
        Generates ARIMA forecasts for one or more time series.
        Args:
            data (Pandas Data Frame):
                Data must be in wide format.
                Data must have a time-series index
                that is a pandas period.
            h (int):
                The forecast horizon
            sp (int):
                The seasonal period
            alpha (float, optional):
                Contols the confidence interval.
                alpha = 95%
                Defaults to 0.95%
            suppress_warnings (bool, optional):
                Suppresses ARIMA feedback during automated model training.
                Defaults to True.
            args: Passed to sktime.forecasting.arima.AutoARIMA
            kwargs: Passed to sktime.forecasting.arima.AutoARIMA
        Returns:
            Pandas Data Frame:
                - A single time series contains columns: value, prediction, ci_lo, and ci_hi
                - Multiple time series will be returned stacked by group
        """
    model_config = ConfigDict(arbitrary_types_allowed=True)
    data: pd.DataFrame
    h: Annotated[int, Field(strict=True, gt=0)]  # h must be > 0

    sp: Literal[3, 6, 12, 24]
    alpha: Annotated[StrictFloat, Field(strict=True, gt=0, lt=1)] = 0.95
    suppress_warnings: bool = True

    @model_validator(mode="after")
    def validate_fields(self):
        if self.data.empty:
            raise ValueError("Input 'data' must not be empty.")

        if self.data.shape[1] == 0:
            raise ValueError("Input 'data' must have at least one column.")

        if self.data.shape[0] == 0:
            raise ValueError("Input 'data' must have at least one row.")

        return self

    def forecast(self, *args, **kwargs):
        results = {}

        for column in tqdm(self.data.columns, desc="Forecasting", mininterval=0):
            y = self.data[column]

            model = AutoARIMA(
                    sp=self.sp,
                    suppress_warnings=self.suppress_warnings,
                    *args,
                    **kwargs
            )

            model.fit(y)

            fh = np.arange(1, self.h + 1)
            pred = model.predict(fh=fh)
            pred_interval = model.predict_interval(coverage=self.alpha)
            pred_interval.index = pred.index  # Align indices

            result_df = pd.concat([y, pred, pred_interval], axis=1)
            result_df.columns = ["value", "prediction", "ci_lo", "ci_hi"]

            results[column] = result_df

        combined_df = pd.concat(results, axis=0)
        combined_df.index.names = [*self.data.columns.names, *self.data.index.names]
        combined_df = combined_df.reset_index()

        # Drop autogenerated multi-index columns
        keep_columns = ~combined_df.columns.str.startswith("level_")
        return combined_df.loc[:, keep_columns]
